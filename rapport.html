
<!-- saved from url=(0060)http://www-ens.iro.umontreal.ca/~syriani/courses/rapport.htm -->
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="stylesheet" type="text/css" href="css/main.css"/>
        <style id="stndz-style">
        </style>
    <title>IFT3911 DM2 - Hiv 2019</title>
</head>
    <body>
        <h6 style="text-align: center;">Dans ce document, l’emploi du masculin pour désigner des personnes n’a d’autres fins que celle d’alléger le texte.</h6>
        <h2>
            Information générale</h2>
        <p>
            <span style="font-weight: bold;">Nom: </span>EID Alain
            <br>
            <span style="font-weight: bold;">Matricule: </span>20061065
            <br>
            <span style="font-weight: bold;">Courriel: </span>alain.eid@umontreal.ca
            <br>
            <span style="font-weight: bold;">temps mis: </span>22 heures
        </p>
        <p>
            <span style="font-weight: bold;">Nom: </span>STEENHAUT Sami
            <br>
            <span style="font-weight: bold;">Matricule: </span>20061630
            <br>
            <span style="font-weight: bold;">Courriel: </span>sami.steenhaut@umontreal.ca
            <br>
            <span style="font-weight: bold;">temps mis: </span>23 heures
        </p>
        <p>
            <span style="font-weight: bold;">Nom: </span>VOICULESCU Eduard
            <br>
            <span style="font-weight: bold;">Matricule: </span>20078235
            <br>
            <span style="font-weight: bold;">Courriel: </span>eduard.voiculescu@umontreal.ca
            <br>
            <span style="font-weight: bold;">temps mis: </span>25 heures
        </p>
        <h2>
            Distribution des tâches</h2>
        <p>
            <span style="font-weight: bold;">Soumetteur: </span>VOICULESCU Eduard
        </p>
        <table class="item">
            <thead>
                <tr>
                    <th>
                        Tâche
                    </th>
                    <th>
                        Alain
                    </th>
                    <th>
                        Sami
                    </th>
                    <th>
                        Eduard
                    </th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        Design logiciel [55%] :<br>
                        <ul>
                            <li>Diagramme de classe [20%]</li>
                            <li>Diagrammes de séquence ou de collaboration [15%]<br>
                                <ul>
                                    <li>vérifier les vols/itinéraires disponibles</li>
                                    <li>réserver un siège/cabine</li>
                                    <li>payer un siège/cabine</li>
                                    <li>annuler une réservation</li>
                                    <li>changer une réservation</li>
                                </ul>
                            </li>
                            <li>Diagramme de paquets [8%]</li>
                            <li>Contraintes OCL [7%]<br>
                                <ul>
                                    <li>Le port de départ et d'arrivée doit être le même [OCL].</li>

                                    <li>Un paquebot peut être assigné à plusieurs itinéraires tant qu'ils ne se chevauchent pas [OCL].</li>

                                    <li>Réserver ne peut se faire que pour un siège/cabine libre [OCL].</li>

                                </ul>
                            </li>
                            <li>Identifications des modules réutilisables [5%]</li>
                        </ul>
                    </td>
                    <td>
                        33%
                    </td>
                    <td>
                        33%
                    </td>
                    <td>
                        33%
                    </td>
                </tr>
                <tr>
                    <td>
                        Qualité du design [45%]: <br>
                        <ul>
                            <li>Discussion du couplage et de la cohésion des modules [10%]</li>
                            <li>Discussion du fardeau des classes [10%]</li>
                            <li>Graphe IA et justification [10%]</li>
                            <li>Justification de l'application des principes de conception [15%]</li>
                        </ul>
                    </td>
                    <td>30%</td>
                    <td>30%</td>
                    <td>40%</td>
                </tr>
                <tr>
                    <td>
                        Justifications ? (voir plus bas)
                    </td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>
                        Bonus (pas de note partielle) [10%]
                    </td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </tbody>
        </table>

        <!-- Début section : Design logiciel-->
        <h3>Design logiciel:</h3>

        <h4>Diagramme de classe: </h4>
        <img src="design/ClassDiagram.jpg"/>
        <h4>Diagramme de séquence ou de collaboration:</h4>
        <p>Vérifier les vols/itinéraires disponibles</p>
        <img src="design/checkAvailableFlightsOrItineraries.jpg"/>
        <p>Réserver un siège/cabine</p>
        <img src="design/reserveSeat.jpg"/>
        <p>Payer un siège/cabine</p>
        <img src="design/paySeat.jpg"/>
        <p>Annuler une réservation</p>
        <img src="design/cancelReservation.jpg"/>
        <p>Changer une réservation</p>
        <img src="design/changeReservation.jpg"/>
        <h4>Diagramme de paquets</h4>
        <img src="design/packageDiagram.jpg"/>

        <h4>Contraintes OCL</h4>
        <p>Le port de départ et d'arrivée doit être le même</p>
        <p>context DestinationCourseCruise inv:</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;self.destinationDeparture = self.destinationArrival</p>
        <p>Un paquebot peut être assigné à plusieurs itinéraires tant qu'ils ne se chevauchent pas.</p>
        <p>context DestinationCourseCruise inv:</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;self.allInstances()->forAll(d1,d2 | d1.transportId = d2.transportId implies d1.arrivalTime < d2.departureTime OR d1.departureTime > d2.arrivalTime)</p>
        <p>Réserver ne peut se faire que pour un siège/cabine libre.</p>
        <p>context SectionPlace::reserved():Boolean</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;pre : self.status = "FREE"<br>
            &nbsp;&nbsp;&nbsp;&nbsp;post : self.status = "RESERVED"</p>

        <h4>Identifications des modules réutilisables</h4>
        <!-- Fin section : Design logiciel-->

        <!-- Début section : Qualité du design -->
        <h3>Qualité du design:</h3>

        <h3>Discussion du couplage et de la cohésion des modules</h3>
        <p>Cette section sera divisé en 3 sous sections.</p>
        <ol>
        <li>Le couplage</li>
        <li>La cohésion</li>
        </ol>
        <h4>Le couplage</h4>
        <p>Nous avons remarqué que nos classes pouvaient être regroupé en 3 "types" de classes. Nous avons les classes <strong>objets (abstraites et leurs enfants)</strong>, les classes de <strong>bases de données</strong> et les classes <strong>contrôleurs</strong>.</p>
        <p>Pour le type des classes <strong>contrôleurs</strong> ainsi que les UI, nous remarquons que toutes ces classes ont comme type de couplage un couplage par paquet. La raison est que souvent nous envoyons un objet au complet au contrôleurs et que seulement une partie des informations de cet objet est utilisée.</p>
        <dl>
          <dt><strong>Classes contrôleurs:</strong></dt>
          <dd>UserController</dd>
          <dd>ServiceController</dd>
          <dd>TransportCompanyController</dd>
          <dd>TransportController</dd>
          <dd>DestinationCOurseController</dd>
          <dd>ReservationController</dd>
          <dd>TransactionCOntroller</dd>
        </dl>
        <p>Pour le type des classes <strong>bases de données</strong>, nous remarquons que toutes ces classes ont comme type de couplage un couplage par données. La raison est que souvent nous envoyons un objet au complet à la base de données et elle garde TOUTES les informations de l'objet.</p>
        <dl>
          <dt><strong>Classes de bases de données:</strong></dt>
          <dd>ServiceDatabase</dd>
          <dd>TransportCompanyDatabase</dd>
          <dd>UserDatabase</dd>
          <dd>ServiceDatabase</dd>
          <dd>TransactionDatabase</dd>
          <dd>TransportDatabase</dd>
          <dd>DestinationCourseDatabase</dd>
          <dd>ReservationDatabase</dd>
        </dl>
        <p>Pour le type des classes <strong>objets (abstraites et leurs enfants):</strong>, nous remarquons que toutes ces classes ont comme type de couplage un couplage par données. La raison est que ces classes ne servent qu'à envoyé des données. On pourrait aussi penser que c'est de type par paquet, car on accède souvent à trop d'éléments de cette strature de données.</p>
        <dl>
          <dt><strong>Classes objets (abstraites et leurs enfants):</strong></dt>
          <dd>Transaction</dd>
          <dd>Reservation</dd>
          <dd>User</dd>
          <dd>Service</dd>
          <dd>City</dd>
          <dd>Transport*</dd>
          <dd>Section*</dd>
          <dd>SectionPlace*</dd>
          <dd>DestinationCourse</dd>
        </dl>
        <p>On peut remarqué les astérix à Transport, Section et SectionPlace. Nous les avons placé là, car entre elles, ces classes ont un couplage par contrôle. La raison est que si transport n'existe pas, section n'éxiste pas et si section n'éxiste pas, sectionplace assigné à la section n'éxiste pas.Il en de même pour les classes UI, si elle n'éxiste pas, les accès aux autres classes sont impossibles.</p>
        <dt><strong>Classes UI</strong>
          <dd>AdminUI</dd>
          <dd>ClientUI</dd>
          <dd>SystemUI</dd>
        </dt>
        <h4>Mesure de couplage par CBO</h3>
          <dl>
            <dt><strong>Classes contrôleurs:</strong></dt>
            <dd>UserController : 3</dd>
            <dd>ServiceController : 3</dd>
            <dd>TransportCompanyController : 3</dd>
            <dd>TransportController : 3</dd>
            <dd>DestinationCOurseController : 4</dd>
            <dd>ReservationController : 6</dd>
            <dd>TransactionCOntroller : 3</dd>
          </dl>
          <dl>
          <dt><strong>Classes UI:</strong></dt>
            <dd>AdminUI : 4</dd>
            <dd>ClientUI : 2</dd>
            <dd>SystemUI : 3</dd>
          </dl>
          <dl>
            <dt><strong>Classes de bases de données:</strong></dt>
            <dd>ServiceDatabase : 1</dd>
            <dd>TransportCompanyDatabase : 1</dd>
            <dd>UserDatabase : 1</dd>
            <dd>ServiceDatabase : 1</dd>
            <dd>TransactionDatabase : 1</dd>
            <dd>TransportDatabase : 1</dd>
            <dd>DestinationCourseDatabase : 1</dd>
            <dd>ReservationDatabase : 1</dd>
          </dl>
          <dl>
            <dt><strong>Classes objets (abstraites et leurs enfants):</strong></dt>
            <dd>Transaction : 1</dd>
            <dd>Reservation : 1</dd>
            <dd>User : 1</dd>
            <dd>Service : 2</dd>
            <dd>City : 1</dd>
            <dd>TransportCompany : 1</dd>
            <dd>Transport* : 2</dd>
            <dd>Section* : 2</dd>
            <dd>SectionPlace* : 1</dd>
            <dd>DestinationCourse : 1</dd>
          </dl>
        <p>On peut voir que les résultats des mesures de CBO suivent la même tendance que les types de couplages que nous avons discuté.<br>*sauf pour certaines exeptions où le couplage est très élévé* </p>
        <p>Pour l'odre d'implémentation et la génération de code, il faudrait suivre en ordre croissant la mesure de CBO des classes à commencer par :<br> <strong>Classes objets</strong> &rarr; <strong>Classes de bases de données</strong> &rarr; <strong>Classes contrôleurs</strong> &rarr; <strong>Classes UI</strong>.</p>
        <h3>La cohésion</h3>
        <p>Nous avons fait notre possible pour avoir un cohésion la plus forte possible en ayant des classes qui avait des fonctions précises! Nous allons continuer avec les groupes des classes dans la section couplage.</p>
        <p>Pour le type des classes <strong>contrôleurs</strong>, nous avons une cohésion communicationnelle, car ce sont tous des modules qui effectuent une série d'actions reliées par la procédure que l'objet, dont le contrôleur est responsable, doit suivre. Les actions que les classes de contrôleurs effectuent opèrent aussi sur ces mêmes objets. La cohésions des classes contrôleurs est donc forte.</p>
        <p>Pour le type des classes de<strong>base de données</strong>, nous avons une cohésion fonctionnelle, car ce sont tous des modules qui contribue à éxactement une seule tâche soit mettre dans un dictionnaire des objets de même type. Les même opérations peut être réutilisée dans our n'importe quels objets stockés dans une base de données. La cohésions des classes de base de donnée est donc très forte.</p>
        <p>Pour le type des classes de<strong>objets (abstraites et leurs enfants)</strong>, nous avons une cohésion informationnelle, car ce sont tous des modules qui effectuent plusieurs actions différentes mais qui travail sur le même obejts. La cohésions des classes des objects est donc forte.</p>
        <p>Pour le type des classes de<strong>UI</strong>, la cohésions des classes des UI est forte.</p>


        <h3>Discussion du fardeau des classes</h3>
        <p>Calcul du fardeau des classes</p>

        <table class="item">
            <thead>
                <th>Classe</th>
                <th>Fardeau</th>
                <th>Réutilisation</th>
                <th>Domaine</th>
            </thead>
            <tbody>
                <tr>
                    <td>User</td>
                    <td>F(String) + 1 + F(Date) + 1 = 0 + 1 + 0 + 1 = 2</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>UserClient</td>
                    <td>F(User) + 1 = 3</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>UserAdmin</td>
                    <td>F(User) + 1 = 3</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>UserDatabase</td>
                    <td>F(HashMap) + 1 + F(User) + 1 = 0 + 1 + 2 + 1 = 4</td>
                    <td>Moyenne</td>
                    <td>Architecture</td>
                </tr>
                <tr>
                    <td>UserController</td>
                    <td>F(UserDatabase) + 1 = 4 + 1 = 5</td>
                    <td>Faible</td>
                    <td>Application</td>
                </tr>
                <tr>
                    <td>SystemUI</td>
                    <td>F(UserController) + 1 + F(ClientUI) + 1 + F(AdminUI) + 1 = 5 + 1 + 38 + 1 + 38 + 1 = 84</td>
                    <td>Élevée</td>
                    <td>Application</td>
                </tr>
                <tr>
                    <td>ClientUI</td>
                    <td>F(ReservationController) + 1 = 37 + 1 = 38</td>
                    <td>Élevée</td>
                    <td>Application</td>
                </tr>
                <tr>
                    <td>AdminUI</td>
                    <td>F(ServiceController) + 1 + F(TransactionController) + 1 + F(DestinationCourseController) + 1 = 6 + 1 + 22 + 1 + 7 + 1 = 38</td>
                    <td>Élevée</td>
                    <td>Application</td>
                </tr>
                <tr>
                    <td>ReservationController</td>
                    <td>F(ReservationDatabase) + 1 + F(DestinationCourseController) + 1 + F(TransactionController) + 1 = 5 + 1 + 7 + 1 + 22 + 1 = 37</td>
                    <td>Faible</td>
                    <td>Application</td>
                </tr>
                <tr>
                    <td>ReservationDatabase</td>
                    <td>F(HashMap) + 1 + F(Reservation) + 1 = 0 + 1 + 3 + 1 = 5</td>
                    <td>Moyenne</td>
                    <td>Architecture</td>
                </tr>
                <tr>
                    <td>Reservation</td>
                    <td>F(String) + 1 + F(ReservationStatus) + 1 + F(Date) + 1 = 0 + 1 + 0 + 1 + 0 + 1 = 3</td>
                    <td>Élevée</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>TransactionController</td>
                    <td>F(TransactionDatabase) + 1 + F(ReservationController) + 1 = 5 + 1 + 15 + 1 = 22</td>
                    <td>Faible</td>
                    <td>Application</td>
                </tr>
                <tr>
                    <td>TransactionDatabase</td>
                    <td>F(Transaction) + 1 + F(HashMap) + 1 = 3 + 1 + 0 + 1 = 5</td>
                    <td>Moyenne</td>
                    <td>Architecture</td>
                </tr>
                <tr>
                    <td>Transaction</td>
                    <td>F(String) + 1 + F(Double) + 1 + F(Date) + 1 = 0 + 1 + 0 + 1 + 0 + 1 = 3</td>
                    <td>Élevée</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>TransportController</td>
                    <td>F(TransportDatabase) + 1 + F(Boolean) + 1 = 9 + 1 + 0 + 1 = 11</td>
                    <td>Faible</td>
                    <td>Application</td>
                </tr>
                <tr>
                    <td>TransportDatabase</td>
                    <td>F(HashMap) + 1 + F(Transport) + 1 = 0 + 1 + 7 + 1 = 9</td>
                    <td>Moyenne</td>
                    <td>Architecture</td>
                </tr>
                <tr>
                    <td>Transport</td>
                    <td>F(String) + 1 + F(Section) + 1 + F(List) + 1 = 0 + 1 + 4 + 1 + 0 + 1 = 7</td>
                    <td>Élevée</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>TransportAirplane</td>
                    <td>F(Transport) + 1 + F(int) + 1 = 7 + 1 + 0 + 1 = 9</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>TransportBoat</td>
                    <td>F(Transport) + 1 + F(int) + 1 = 7 + 1 + 0 + 1 = 9</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>TransportTrain</td>
                    <td>F(Transport) + 1 + F(int) + 1 = 7 + 1 + 0 + 1 = 9</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>Section</td>
                    <td>F(Double) + 1 + F(SectionPlace) + 1 + F(List) + 1 = 0 + 1 + 1 + 1 + 0 + 1 = 4</td>
                    <td>Élevée</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionCabin</td>
                    <td>F(Section) + 1 + F(int) + 1 = 4 + 1 + 0 + 1 = 6</td>
                    <td>Élevée</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionCabinInterieur</td>
                    <td>F(SectionCabin) + 1 = 6 + 1 = 7</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionCabinOcean</td>
                    <td>F(SectionCabin) + 1 = 6 + 1 = 7</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionCabinSuite</td>
                    <td>F(SectionCabin) + 1 = 6 + 1 = 7</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionCabinFamille</td>
                    <td>F(SectionCabin) + 1 = 6 + 1 = 7</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionCabinDeluxe</td>
                    <td>F(SectionCabin) + 1 = 6 + 1 = 7</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionAirplane</td>
                    <td>F(Section) + 1 = 4 + 1 = 5</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionAirplaneFirstClass</td>
                    <td>F(SectionAirplane) + 1 = 5 + 1 = 6</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionAirplaneBuisnessClass</td>
                    <td>F(SectionAirplane) + 1 = 5 + 1 = 6</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionAirplanePremiumClass</td>
                    <td>F(SectionAirplane) + 1 = 5 + 1 = 6</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionAirplaneEconomicClass</td>
                    <td>F(SectionAirplane) + 1 = 5 + 1 = 6</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionTrain</td>
                    <td>F(Section) + 1 + F(SectionPlaceNarrowSeat) + 1 = 4 + 1 + 10 + 1 = 16</td>
                    <td>Élevée</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionTrainPremium</td>
                    <td>F(SectionTrain) + 1 = 16 + 1 = 17</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionTrainEconomicClass</td>
                    <td>F(SectionTrain) + 1 = 16 + 1 = 17</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionPlace</td>
                    <td>F(String) + 1 = 0 + 1 = 1</td>
                    <td>Élevée</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionPlaceCabin</td>
                    <td>F(SectionPlace) + 1 + F(int) + 1 + F(Status) + 1 = 1 + 1 + 0 + 1 + 0 + 1 = 4</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionPlaceSeat</td>
                    <td>F(SectionPlace) + 1 + F(Position) + 1 + F(Time) + 1 + F(SectionAirplane) + 1 = 1 + 1 + 0 + 1 + 5 + 1 = 9</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionPlaceNarrowSeat</td>
                    <td>F(SectionPlaceSeat) + 1 = 10</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionPlaceConfortSeat</td>
                    <td>F(SectionPlaceSeat) + 1 = 10</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionPlaceMediumSeat</td>
                    <td>F(SectionPlaceSeat) + 1 = 10</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>SectionPlaceLargeSeat</td>
                    <td>F(SectionPlaceSeat) + 1 = 10</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>DestinationCourseController</td>
                    <td>F(DestinationCourseDatabase) + 1 = 6 + 1 = 7</td>
                    <td>Faible</td>
                    <td>Application</td>
                </tr>
                <tr>
                    <td>DestinationCourseDatabase</td>
                    <td>F(HashMap) + 1 + F(DestinationCourse) + 1 = 0 + 1 + 4 + 1 = 6</td>
                    <td>Moyenne</td>
                    <td>Architecture</td>
                </tr>
                <tr>
                    <td>DestinationCourse</td>
                    <td>F(Date) + 1 + F(Double) + 1 + F(City) + 1 = 0 + 1 + 0 + 1 + 1 + 1 = 4</td>
                    <td>Élevée</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>DestinationCourseFlight</td>
                    <td>F(DestinationCourse) + 1 = 4 + 1 = 5</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>DestinationCourseCruise</td>
                    <td>F(DestinationCourse) + 1 = 4 + 1 = 5</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>DestinationCourseTrain</td>
                    <td>F(DestinationCourse) + 1 = 4 + 1 = 5</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>ServiceController</td>
                    <td>F(ServiceDatabase) + 1 + F(Boolean) + 1 = 4 + 1 + 0 + 1 = 6</td>
                    <td>Faible</td>
                    <td>Application</td>
                </tr>
                <tr>
                    <td>ServiceDatabase</td>
                    <td>F(HashMap) + 1 + F(Service) + 1 = 0 + 1 + 2 + 1 = 4</td>
                    <td>Moyenne</td>
                    <td>Architecture</td>
                </tr>
                <tr>
                    <td>Service</td>
                    <td>F(City) + 1 = 2</td>
                    <td>Élevée</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>ServiceAirport</td>
                    <td>F(Service) + 1 = 3</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>ServicePort</td>
                    <td>F(Service) + 1 = 3</td>
                    <td>ÉlMoyenneevée</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>ServiceStation</td>
                    <td>F(Service) + 1 = 3</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>City</td>
                    <td>F(String) + 1 = 1</td>
                    <td>Élevée</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>TransportCompanyController</td>
                    <td>F(TransportCompanyDatabase) + 1 + F(Boolean) + 1 = 3 + 1 + 0 + 1 = 5</td>
                    <td>Faible</td>
                    <td>Application</td>
                </tr>
                <tr>
                    <td>TransportCompanyDatabase</td>
                    <td>F(HashMap) + 1 + F(TransportCompany) + 1 = 1 + 1 + 1 = 3</td>
                    <td>Moyenne</td>
                    <td>Architecture</td>
                </tr>
                <tr>
                    <td>TransportCompany</td>
                    <td>F(String) + 1 = 1</td>
                    <td>Élevée</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>TransportCompanyAirline</td>
                    <td>F(TransportCompany) + 1 = 1 + 1 = 2</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>TransportCompanyCruise</td>
                    <td>F(TransportCompany) + 1 = 1 + 1 = 2</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>TransportCompanyTrain</td>
                    <td>F(TransportCompany) + 1 = 1 + 1 = 2</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>ReservationStatus (Enumeration)</td>
                    <td>0</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>Status (Enumeration)</td>
                    <td>0</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
                <tr>
                    <td>Position (Enumeration)</td>
                    <td>0</td>
                    <td>Moyenne</td>
                    <td>Métier</td>
                </tr>
            </tbody>
        </table>
        <br>
        <p>
            Notre système de gestion de réservation généralisé est modélisé en MVC (Model View Controller). Nous avons fait en sorte
            de bien séparer les tâches que les différentes parties de notre système doit faire. Le niveau de sophistication d'une majorité
            des classes est du domaine de métier. Puisque c'est un système assez précis en tant que tel, les classes utiles sont plus spécifiques
            pour un seul type de métier. Le niveau de réutilisation des classes du domaine de métier est variant entre moyenne et élevé (pour certain cas).
            Les controlleurs : UserController, ReservationController, TransactionController, TransportController, DestinationCourseController, ServiceController et TransportCompanyController
            sont tous des classes faisant partie du domaine d'application. La raison est que ces contrôlleurs reste assez restictif en terme de réutilisation.
            Ces contrôleurs sont des classes utilies pour l'application de notre système de gestion de réservation généralisé. Peut-etre que le contôlleur de
            TransactionController pourrait être plus du type domaine de métier puisque ce dernier pourrait être appliqué dans de différent domaine. Mais face à notre
            système et particulièrement face aux spécifications que ce dernier offre, nous l'avons toutefois classifé comme faisant partie du domaien d'application.
            Pour les classes de databases : UserDatabase, ReservationDatabase, TransactionDatabase, TransportDatabase, DestinationCourseDatabase, ServiceDatabase, TransportCompanyDatabase,
            ces dernières font parties du domaine d'architecture avec une réutilisation moyenne. Bien évidemment, puisque nous avons fait un approche MVC et
            puisque nous avons fait beaucoup d'héritage d'objet, il y a certaine classe qui ont un fardeau assez élevé.
        </p>

        <h3>Graphe IA et justification</h3>
        <h3>Justification de l'application des principes de conception</h3>

        <table class="item">
            <thead>
                <th>Instabilité</th>
                <th>Abstabilité</th>
                <th>Paquet</th>
            </thead>
            <tbody>
                <tr>
                    <td>0</td>
                    <td>0.2</td>
                    <td>User</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>0</td>
                    <td>Ui</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0.14</td>
                    <td>Service</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0.17</td>
                    <td>Destination</td>
                </tr>
                <tr>
                    <td>0.75</td>
                    <td>0</td>
                    <td>Reservation</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0</td>
                    <td>Transaction</td>
                </tr>
                <tr>
                    <td>0.33</td>
                    <td>0.17</td>
                    <td>Transport</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0.27</td>
                    <td>Section</td>
                </tr>
            </tbody>
        </table>
        <h4>Résumé</h4>
        <p>
            Selon le principe de Stable Dependencies Principle, un paquet doit dépendre uniquement de paquets <b>plus stables</b> que lui. Cela 
            a pour but de limiter l'impact des changements et cela maximise la stabilité globale de l'application
        </p>
        <p>User(instabilité = 0) dépend de rien.<br><br>

        UI(instabilité = 1) dépend de User(instabilité = 0) , ce qui est parfait, car UI dépend d'un paquet plus stable que lui même.<br>
        UI(instabilité = 1) dépend de Service(instabilité = 0), ce qui est parfait, car UI dépend d'un paquet plus stable que lui même.<br>
        UI(instabilité = 1) dépend de Destination(instabilité = 0), ce qui est parfait, car UI dépend d'un paquet plus stable que lui même.<br>
        UI(instabilité = 1) dépend de Réservation(instabilité = 0.75), ce qui est bon, car UI dépend d'un paquet plus stable que lui même.<br>
        UI(instabilité = 1) dépend de Transport(instabilité = 0.33), ce qui est très bien, car UI dépend d'un paquet plus stable que lui même.<br><br>

        Service(instabilité = 0) dépend de rien.<br><br>

        Destination(instabilité = 0) dépend de User.<br><br>

        Reservation(instabilité = 0.75) dépend de Transport(instabilité = 0.33), ce qui est bon, car UI dépend d'un paquet plus stable que lui même.<br>
        Reservation(instabilité = 0.75) dépend de Destination(instabilité = 0), ce qui est parfait, car UI dépend d'un paquet plus stable que lui même.<br>
        Reservation(instabilité = 0.75) dépend de Transaction(instabilité = 0), ce qui est parfait, car UI dépend d'un paquet plus stable que lui même.<br><br>

        Transaction(instabilité = 0) dépend de rien.<br><br>

        Transport(instabilité = 0.33) dépend de Section(instabilité = 0), ce qui est parfait, car UI dépend d'un paquet plus stable que lui même.<br><br>

        Section(instabilité = 0) dépend de rien.<br><br>

        En résumé, nos dépendances( au niveau de la stabilité )sont parfaites.</p>
        <br>
        <img src="design/grapheIA.png" class="center"/>
        <p>
            Pour faire discussion sur le graphe IA, comme on peut voir dans le graphe, notre Système de Gestion de Réservation Généralisé n'est pas tout à fait parfait.
            Que ce soit une erreur dans l'implémentation de notre diagramme de classe ou dans notre diagramme de paquet, il y a toutefois quelques soucis.
            Nos paquets Ui et reservation se situe très proche de la ligne de MainSequence. Les paquets Ui et reservation sont instables et sont concrets. Cela
            est bon, puisque dans le design de conception du logiciel, on veut se trouver le plus possible sur la droite MainSequence. Si on est pour avoir des classes
            instabales, ces dernières doivent être concrêtes (proche du point (1,0)). Si d'une autre part, les classes sont très stables, ces classes
            devraient être abstaites (proche du point (0,1)). D'une autre part, les paquets section, user, destination, service et transaction sont des paquets avec aucune instabilité
            (ils sont stables comme paquets) et ils sont peu ou presque pas d'abstraction. Malheureusement, cela places ces paquets (section, user, destination, service et transaction)
            dans la "Zone of Pain" puisque leur degré d'abstraction est bas et leur degré d'instabilité est bas ou non-existant. Le paquet transport se trouve entre la
            "Zone of Pain" et la droite descendante de MainSequence. Pour faire part d'un commentaire, il semble que la métrique pour calculer l'abstraction d'un paquet reste
            assez vague en tant que telle. Un exemple serai une classe ayant 10 méthodes concretes mais ayant 1 méthode virtuelle et cette dernière serai classé
            comme une classe ayant seulement des méthodes virtuelles (source : https://www.cs.utexas.edu/users/downing/papers/Stability-1996.pdf).
        </p>

        <p>Nous avons le paquet UI qui dépend du paquet User </p>
        
        <h3>Justification de l'application des principes de conception </h3>
        
        <h3>Principes de conception</h3>
        <p>
        <strong>Open/Closed Principle </strong><br>

        Dans la conception du système, nous avons grandement utilisé l'abstraction pour implémenter des éléments similaires,
        mais tout de même distincts. Nous avons utilisé des classes abstraites notamment pour définir les éléments généraux
        comme Section, SectionCabin, SectionTrain, SectionAirplane, SectionPlace et SectionPlaceSeat
        puis nous avons implémenter avec des classes concrètes les éléments plus spécifiques propres aux éléments précédents
        comme SectionCabinInterieure, SectionTrainPremiumClass, SectionAirplaneFirstClass, SectionPlaceNarrowSeat, etc. Cette
        conception respecte le Open/Closed Principle puisque nous avons étendu les classes générales et abstraites pour définir
        des éléments spécifiques avec des classes concrètes. De plus, ces classes concètes restent ouvertes à l'extension, si
        nécessaire. D'autres abstractions similaires ont été utilisées dans notre conception et peuvent être observées dans notre
        diagramme de classes. <br> <br>

        <strong>Single Responsibility Principle</strong><br>
        Nous avons élaboré une conception selon laquelle chaque classe a une seule fonctionnalité. En effet, les classes de modèle
        servent uniquement de modèle, les classes Database servent uniquement à stocker de l'information et les classes de vue servent 
        uniquement à l'affichage. Cela fait en sorte que si nous voudrions ajouter une autre fonctionnalité à une de ces classes, 
        nous devrons créer une nouvelle classe dans le but de préserver le principe de responsabilité unique. Donc, notre conception
        respecte le Single Responsibility Principle.<br><br>

        <strong>Dependancy Inversion Principle </strong><br>
        Nous utilisions bien le Dependency Inversion Principle(DPI) car la majorité de nos contrôleurs sont dépendants de classes abstraites, par exemple le transportController est dépendant de Transport qui est une classe abstraite, DestinationCourseController est aussi dépendant d'une classe abstraite qui est DestinationCourse, etc. <br><br>

        <strong>Composite Reuse Principle</strong><br>
        Nous n'utilisons pas bien le Composite Reuse Principle, car on peut le voir quand on attribue le modificateur de prix pour chaque type de section, on récrit le même code, quand on aurait pu créer une classe ModificationPrice qui serait abstrait avec des classe qui extends dans le genre PremierModificationPrice(),EconomiqueModificationPrice, ect.<br><br>

        <strong>Stable Abstractions Principle</strong> <br>
        On peut voir avec le Graphe IA, que ce principe n'est pratiquement pas respecté. On a presque toutes nos classes dans la dead zone. On espère fortement que c'est une erreur de calcul...<br><br>

        <strong>Stable Dependancies Principle</strong><br>
        Si on se fit à la section avec le Graphe IA, on peut voir qu'on respecte à la perfection ce principe.<br><br>

        <strong>Acyclic Dependency Principle</strong><br>
        En se référant au diagramme de paquets, on peut constater que les dépendances entre les paquets ne forment pas de cycles et donc
        notre conception respecte le Acyclic Dependency Principle.
        </p>
        <!-- Fin section : Qualité du design -->

        <!-- Début section : Justifications -->
        <h3>
            Justifications:
        </h3>
        <ul>
            <li>
                Comme détail d'implémentation, nous avons décidé d'omettre les fonctions pour modifier un transport tel quel.
                Disons que nous avons un train, un avion ou un paquebot, il est possible de les créer et de les supprimer du système
                mais on ne peut pas les modifier. La seule chose qui pourrait être modifié serai le id du transport. Mais nous ne voyons
                pas le but de permettre cela. Une fois que nous avons un moyen de transport, ce dernier sera prséent dans le système pour
                un bon nombre d'année (bris/problème quelconque/etc.). Nous avons surtout vue cela que lorsque les ingénieurs
                d'une compagnie quelconque construisent un transport, on peut pas les modifier. C'est des objet immutables.
            </li>
            <li>
                Prenez note que pour le calcul du fardeau, nous n'avons pas compté void comme étant un type en Java. Puisque c'est un
                "uninstantiable placeholder" nous assumons que c'est pas un type. Voir la doc pour plus d'information: https://docs.oracle.com/javase/7/docs/api/java/lang/Void.html <br>
                De plus, nous avons considéré HashMap et List comme étant des classes de fondation avec un fardeau de 0.
            </li>
        </ul>
        <!-- Fin section : Justifications-->
    </body>
</html>
